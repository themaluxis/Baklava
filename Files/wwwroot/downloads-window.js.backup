/**
 * Downloads Window
 * Manages download queue and status with header button and dropdown window
 */
(function() {
    'use strict';
    
    // ============================================
    // SHARED STATE & CONFIGURATION
    // ============================================
    
    let isAdmin = false;
    let currentUsername = '';
    let isLoadingDownloads = false;
    
    // UI References
    let dropdownMenu = null;
    let backdrop = null;
    let progressPollingInterval = null;

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    async function checkAdmin() {
        if (!window.ApiClient) return false;
        
        try {
            const userId = window.ApiClient.getCurrentUserId();
            const user = await window.ApiClient.getUser(userId);
            isAdmin = user?.Policy?.IsAdministrator || false;
            currentUsername = user?.Name || 'Unknown';
            return isAdmin;
        } catch (err) {
            try {
                const user = await window.ApiClient.getCurrentUser();
                isAdmin = user?.Policy?.IsAdministrator || false;
                currentUsername = user?.Name || 'Unknown';
                return isAdmin;
            } catch {
                return false;
            }
        }
    }

    // ============================================
    // DOWNLOAD CARDS
    // ============================================

    function createDownloadCard(download) {
        const card = document.createElement('div');
        card.className = 'download-card';
        card.setAttribute('data-download-id', download.id);
        card.style.cssText = `
            display: inline-block;
            width: 130px;
            margin: 10px;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
        `;

        // Poster image
        const imgDiv = document.createElement('div');
        imgDiv.style.cssText = `
            width: 100%;
            height: 195px;
            border-radius: 6px;
            margin-bottom: 8px;
            background-size: cover;
            background-position: center;
            background-color: #1a1a1a;
            position: relative;
            overflow: hidden;
        `;

        if (download.img) {
            imgDiv.style.backgroundImage = `url(${download.img})`;
        } else {
            imgDiv.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            const placeholderIcon = document.createElement('div');
            placeholderIcon.innerHTML = '<span class="material-icons" style="font-size: 48px; color: rgba(255,255,255,0.3);">movie</span>';
            placeholderIcon.style.cssText = 'display: flex; align-items: center; justify-content: center; height: 100%;';
            imgDiv.appendChild(placeholderIcon);
        }

        // Progress overlay (only for active downloads)
        if (download.status === 'active') {
            const progressOverlay = document.createElement('div');
            progressOverlay.className = 'download-progress-overlay';
            progressOverlay.style.cssText = `
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: rgba(0, 0, 0, 0.85);
                padding: 8px;
            `;

            const progressBar = document.createElement('div');
            progressBar.style.cssText = `
                width: 100%;
                height: 4px;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 2px;
                overflow: hidden;
                margin-bottom: 4px;
            `;

            const progressFill = document.createElement('div');
            progressFill.className = 'download-progress-fill';
            progressFill.style.cssText = `
                height: 100%;
                background: #00a4dc;
                width: ${download.progress || 0}%;
                transition: width 0.3s ease;
            `;
            progressBar.appendChild(progressFill);

            const progressText = document.createElement('div');
            progressText.className = 'download-progress-text';
            progressText.textContent = `${Math.round(download.progress || 0)}%`;
            progressText.style.cssText = `
                color: #fff;
                font-size: 11px;
                text-align: center;
            `;

            progressOverlay.appendChild(progressBar);
            progressOverlay.appendChild(progressText);
            imgDiv.appendChild(progressOverlay);
        }

        // Status badge
        const statusBadge = document.createElement('div');
        statusBadge.style.cssText = `
            position: absolute;
            top: 6px;
            right: 6px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        `;

        switch (download.status) {
            case 'active':
                statusBadge.style.background = '#2196F3';
                statusBadge.style.color = '#fff';
                statusBadge.textContent = 'Downloading';
                break;
            case 'queued':
                statusBadge.style.background = '#FF9800';
                statusBadge.style.color = '#fff';
                statusBadge.textContent = 'Queued';
                break;
            case 'completed':
                statusBadge.style.background = '#4CAF50';
                statusBadge.style.color = '#fff';
                statusBadge.textContent = 'Done';
                break;
            case 'failed':
                statusBadge.style.background = '#F44336';
                statusBadge.style.color = '#fff';
                statusBadge.textContent = 'Failed';
                break;
        }
        imgDiv.appendChild(statusBadge);

        card.appendChild(imgDiv);

        // Title
        const title = document.createElement('div');
        title.textContent = download.title;
        title.style.cssText = `
            color: #e6e6e6;
            font-size: 13px;
            margin-bottom: 3px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        `;
        card.appendChild(title);

        // Year
        if (download.year) {
            const year = document.createElement('div');
            year.textContent = download.year;
            year.style.cssText = `
                color: #999;
                font-size: 11px;
            `;
            card.appendChild(year);
        }

        // Click handler
        card.addEventListener('click', () => {
            openDownloadModal(download);
        });

        // Hover effect
        card.addEventListener('mouseenter', () => {
            card.style.transform = 'scale(1.05)';
        });
        card.addEventListener('mouseleave', () => {
            card.style.transform = 'scale(1)';
        });

        return card;
    }

    function createPlaceholderCard() {
        const card = document.createElement('div');
        card.style.cssText = `
            display: inline-block;
            width: 100px;
            margin: 10px;
            cursor: default;
            text-align: center;
            color: #666;
            position: relative;
        `;

        const imgDiv = document.createElement('div');
        imgDiv.style.cssText = `
            width: 100%;
            height: 150px;
            border-radius: 6px;
            margin-bottom: 8px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px dashed rgba(150,150,150,0.6);
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
        `;

        const inner = document.createElement('div');
        inner.style.cssText = 'width:60%;height:60%;border-radius:4px;';
        imgDiv.appendChild(inner);
        card.appendChild(imgDiv);

        const text = document.createElement('div');
        text.textContent = 'No downloads';
        text.style.cssText = 'font-size: 11px; color: #777;';
        card.appendChild(text);

        return card;
    }

    // ============================================
    // DOWNLOAD MODAL
    // ============================================

    function openDownloadModal(download) {
        // Remove existing modal if any
        const existingModal = document.getElementById('downloadModal');
        if (existingModal) {
            existingModal.remove();
        }

        const modal = document.createElement('div');
        modal.id = 'downloadModal';
        modal.className = 'download-modal-overlay';
        modal.setAttribute('data-download-id', download.id);
        modal.style.cssText = `
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            padding: 24px;
        `;

        const modalContent = document.createElement('div');
        modalContent.className = 'download-modal-content';
        modalContent.style.cssText = `
            background: #181818;
            border-radius: 8px;
            width: min(600px, 90vw);
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            position: relative;
        `;

        // Progress bar at top (for active downloads)
        let progressBarHtml = '';
        if (download.status === 'active') {
            progressBarHtml = `
                <div style="height: 6px; background: rgba(255,255,255,0.1); position: relative; overflow: hidden;">
                    <div class="modal-progress-fill" style="height: 100%; background: linear-gradient(90deg, #00a4dc, #0080ff); width: ${download.progress || 0}%; transition: width 0.5s ease;"></div>
                </div>
            `;
        }

        modalContent.innerHTML = `
            ${progressBarHtml}
            <div style="padding: 24px;">
                <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                    <div style="width: 200px; flex-shrink: 0;">
                        <div style="width: 100%; height: 300px; border-radius: 8px; background-size: cover; background-position: center; background-color: #1a1a1a; ${download.img ? `background-image: url(${download.img});` : 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);'}"></div>
                    </div>
                    <div style="flex: 1;">
                        <h2 style="margin: 0 0 8px 0; color: #fff; font-size: 24px;">${download.title}</h2>
                        ${download.year ? `<div style="color: #999; margin-bottom: 16px;">${download.year}</div>` : ''}
                        
                        <div style="margin-bottom: 16px;">
                            <div style="display: inline-block; padding: 6px 12px; border-radius: 16px; font-size: 12px; font-weight: bold; text-transform: uppercase; 
                                ${download.status === 'active' ? 'background: #2196F3;' : ''}
                                ${download.status === 'queued' ? 'background: #FF9800;' : ''}
                                ${download.status === 'completed' ? 'background: #4CAF50;' : ''}
                                ${download.status === 'failed' ? 'background: #F44336;' : ''}
                                color: #fff;">
                                ${download.status}
                            </div>
                        </div>

                        ${download.status === 'active' ? `
                            <div style="margin-bottom: 20px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="color: #999; font-size: 14px;">Progress</span>
                                    <span class="modal-progress-percentage" style="color: #fff; font-size: 14px; font-weight: bold;">${Math.round(download.progress || 0)}%</span>
                                </div>
                                <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                                    <div class="modal-progress-bar" style="height: 100%; background: linear-gradient(90deg, #00a4dc, #0080ff); width: ${download.progress || 0}%; transition: width 0.5s ease;"></div>
                                </div>
                            </div>
                        ` : ''}

                        ${download.status === 'completed' ? `
                            <div style="margin-top: 24px;">
                                <button class="play-download-btn" style="
                                    background: #00a4dc;
                                    color: #fff;
                                    border: none;
                                    padding: 12px 24px;
                                    border-radius: 6px;
                                    font-size: 16px;
                                    font-weight: bold;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    gap: 8px;
                                    transition: background 0.2s;
                                ">
                                    <span class="material-icons">play_arrow</span>
                                    <span>Play</span>
                                </button>
                            </div>
                        ` : ''}

                        <div style="margin-top: 20px; color: #999; font-size: 13px;">
                            <div>Type: ${download.itemType}</div>
                            ${download.size ? `<div>Size: ${formatBytes(download.size)}</div>` : ''}
                            <div>Started: ${formatDate(download.startedAt)}</div>
                            ${download.completedAt ? `<div>Completed: ${formatDate(download.completedAt)}</div>` : ''}
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                    ${download.status === 'active' ? '<button class="cancel-download-btn" style="background: #f44336; color: #fff; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">Cancel</button>' : ''}
                    ${download.status === 'failed' ? '<button class="retry-download-btn" style="background: #00a4dc; color: #fff; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">Retry</button>' : ''}
                    <button class="close-modal-btn" style="background: #555; color: #fff; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">Close</button>
                </div>
            </div>
        `;

        modal.appendChild(modalContent);
        document.body.appendChild(modal);

        // Event listeners
        modal.querySelector('.close-modal-btn').addEventListener('click', () => {
            modal.remove();
        });

        const cancelBtn = modal.querySelector('.cancel-download-btn');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', async () => {
                if (confirm('Are you sure you want to cancel this download?')) {
                    cancelBtn.disabled = true;
                    cancelBtn.textContent = 'Cancelling...';
                    
                    try {
                        await window.ApiClient.ajax({
                            type: 'DELETE',
                            url: window.ApiClient.getUrl(`api/baklava/downloads/${download.id}`)
                        });
                        modal.remove();
                        loadDropdownDownloads();
                    } catch (err) {
                        cancelBtn.disabled = false;
                        cancelBtn.textContent = 'Cancel';
                    }
                }
            });
        }

        const playBtn = modal.querySelector('.play-download-btn');
        if (playBtn) {
            playBtn.addEventListener('click', () => {
                playDownload(download);
            });
            playBtn.addEventListener('mouseenter', () => {
                playBtn.style.background = '#0080ff';
            });
            playBtn.addEventListener('mouseleave', () => {
                playBtn.style.background = '#00a4dc';
            });
        }

        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
        
        // Prevent modal events from bubbling to page observers
        modalContent.addEventListener('click', (e) => {
            e.stopPropagation();
        });
    }

    function playDownload(download) {
        console.log('[Downloads] playDownload called with:', download);
        
        if (!download.jellyfinId) {
            console.error('[Downloads] No Jellyfin ID found for download');
            alert('Cannot play: No Jellyfin ID associated with this download');
            return;
        }
        
        console.log('[Downloads] jellyfinId:', download.jellyfinId);
        console.log('[Downloads] download.id:', download.id);
        
        const modal = document.getElementById('downloadModal');
        if (modal) modal.remove();
        hideDropdown();
        
        try {
            console.log('[Downloads] Preparing to play with Jellyfin native player...');
            
            // Store download info globally so we can intercept playback
            window._baklavaCurrentDownload = {
                downloadId: download.id,
                jellyfinId: download.jellyfinId,
                streamUrl: window.ApiClient.getUrl(`api/baklava/downloads/${download.id}/stream`)
            };
            
            console.log('[Downloads] Stored download info:', window._baklavaCurrentDownload);
            
            // Navigate to details page and play normally
            // The playback interceptor (if implemented) will redirect to local file
            if (window.Dashboard && window.Dashboard.navigate) {
                const detailsUrl = `#!/details?id=${download.jellyfinId}`;
                console.log('[Downloads] Navigating to:', detailsUrl);
                window.Dashboard.navigate(detailsUrl);
                
                // Wait for page to load, then click play
                setTimeout(() => {
                    console.log('[Downloads] Looking for play button...');
                    const playButton = document.querySelector('.btnPlay, .mainDetailButtons .btnPlay');
                    if (playButton) {
                        console.log('[Downloads] Clicking play button');
                        playButton.click();
                    } else {
                        console.warn('[Downloads] Play button not found');
                    }
                }, 2000);
            } else {
                console.error('[Downloads] Dashboard.navigate not available');
            }
            
        } catch (err) {
            console.error('[Downloads] Error playing download:', err);
            alert('Error playing download: ' + err.message);
        }
    }

    function formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }

    function formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleString();
    }

    // ============================================
    // HEADER DROPDOWN MENU
    // ============================================

    function createBackdrop() {
        if (backdrop) return backdrop;
        
        backdrop = document.createElement('div');
        backdrop.className = 'downloads-backdrop';
        backdrop.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            display: none;
        `;
        
        backdrop.addEventListener('click', () => {
            hideDropdown();
        });
        
        document.body.appendChild(backdrop);
        return backdrop;
    }

    function createDropdown() {
        if (dropdownMenu) return dropdownMenu;
        
        dropdownMenu = document.createElement('div');
        dropdownMenu.className = 'downloads-dropdown';
        dropdownMenu.style.cssText = `
            position: fixed;
            top: 40px;
            bottom: 40px;
            right: 20px;
            left: 20px;
            max-width: 800px;
            margin: 0 auto;
            background: #181818;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
            z-index: 10000;
            display: none;
            overflow: hidden;
            padding: 20px;
            max-height: 80vh;
        `;
        
        dropdownMenu.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #333; padding-bottom: 10px;">
                <h2 style="margin: 0; color: #fff;">Downloads</h2>
                <button class="close-dropdown" title="Close" style="background: #555; border: none; color: #fff; padding: 8px 10px; border-radius: 4px; cursor: pointer; display:flex;align-items:center;justify-content:center;">
                    <span class="material-icons" aria-hidden="true" style="font-size:18px;line-height:1;">close</span>
                </button>
            </div>
            <div class="dropdown-content" style="overflow-y: auto; max-height: calc(100% - 80px);">
                <div class="dropdown-active">
                    <h3 style="color: #1e90ff; margin-bottom: 10px;">Active Downloads</h3>
                    <div class="dropdown-active-container" style="display: flex; flex-wrap: wrap; gap: 15px; min-height: 50px;"></div>
                    <hr style="margin: 20px 0; height: 1px; background: rgba(255,255,255,0.1); border: none;">
                </div>

                <div class="dropdown-queued">
                    <h3 style="color: #ff9800; margin-bottom: 10px;">Queued</h3>
                    <div class="dropdown-queued-container" style="display: flex; flex-wrap: wrap; gap: 15px; min-height: 50px;"></div>
                    <hr style="margin: 20px 0; height: 1px; background: rgba(255,255,255,0.1); border: none;">
                </div>

                <div class="dropdown-completed">
                    <h3 style="color: #4caf50; margin-bottom: 10px;">Completed</h3>
                    <div class="dropdown-completed-container" style="display: flex; flex-wrap: wrap; gap: 15px; min-height: 50px;"></div>
                    <hr style="margin: 20px 0; height: 1px; background: rgba(255,255,255,0.1); border: none;">
                </div>

                <div class="dropdown-failed">
                    <h3 style="color: #f44336; margin-bottom: 10px;">Failed</h3>
                    <div class="dropdown-failed-container" style="display: flex; flex-wrap: wrap; gap: 15px; min-height: 50px;"></div>
                </div>
            </div>
        `;
        
        document.body.appendChild(dropdownMenu);
        
        dropdownMenu.querySelector('.close-dropdown').addEventListener('click', hideDropdown);
        
        return dropdownMenu;
    }

    async function loadDropdownDownloads() {
        if (isLoadingDownloads) return;
        isLoadingDownloads = true;

        const dropdown = createDropdown();
        const activeContainer = dropdown.querySelector('.dropdown-active-container');
        const queuedContainer = dropdown.querySelector('.dropdown-queued-container');
        const completedContainer = dropdown.querySelector('.dropdown-completed-container');
        const failedContainer = dropdown.querySelector('.dropdown-failed-container');

        activeContainer.innerHTML = '<div style="color: #999; padding: 20px;">Loading...</div>';
        queuedContainer.innerHTML = '<div style="color: #999; padding: 20px;">Loading...</div>';
        completedContainer.innerHTML = '<div style="color: #999; padding: 20px;">Loading...</div>';
        failedContainer.innerHTML = '<div style="color: #999; padding: 20px;">Loading...</div>';

        try {
            // Try to get downloads from backend API first
            let activeDownloads = [];
            let completedDownloads = [];
            
            try {
                // Get current user ID
                const userId = window.ApiClient.getCurrentUserId();
                
                const response = await window.ApiClient.ajax({
                    type: 'GET',
                    url: window.ApiClient.getUrl('api/baklava/downloads', { userId: userId }),
                    dataType: 'json'
                });
                
                if (response) {
                    activeDownloads = response.active || [];
                    completedDownloads = response.completed || [];
                    
                    // Convert backend format to frontend format
                    activeDownloads = activeDownloads.map(d => ({
                        id: d.id || d.Id,
                        jellyfinId: d.jellyfinId || d.JellyfinId,
                        title: d.title || d.Title,
                        year: d.year || d.Year,
                        itemType: d.itemType || d.ItemType,
                        status: d.status || d.Status,
                        progress: d.progress || d.Progress || 0,
                        size: d.size || d.Size || 0,
                        startedAt: d.startedAt || d.StartedAt,
                        img: getImageUrlFromJellyfinId(d.jellyfinId || d.JellyfinId)
                    }));
                    
                    completedDownloads = completedDownloads.map(d => ({
                        id: d.id || d.Id,
                        jellyfinId: d.jellyfinId || d.JellyfinId,
                        title: d.title || d.Title,
                        year: d.year || d.Year,
                        itemType: d.itemType || d.ItemType,
                        status: 'completed',
                        progress: 100,
                        size: d.size || d.Size || 0,
                        startedAt: d.startedAt || d.StartedAt,
                        completedAt: d.completedAt || d.CompletedAt,
                        img: getImageUrlFromJellyfinId(d.jellyfinId || d.JellyfinId)
                    }));
                }
            } catch (apiErr) {
                // Fallback to DownloadManager if API fails
                activeDownloads = window.DownloadManager ? window.DownloadManager.getActiveDownloads() : [];
                completedDownloads = window.DownloadManager ? window.DownloadManager.getCompletedDownloads() : [];
            }
            
            const failedDownloads = window.DownloadManager ? window.DownloadManager.getFailedDownloads() : [];
            
            // Filter queued from active
            const queuedDownloads = activeDownloads.filter(d => d.status === 'queued');
            const actuallyActive = activeDownloads.filter(d => d.status === 'active');
            
            // Populate active
            activeContainer.innerHTML = '';
            if (actuallyActive.length === 0) {
                activeContainer.appendChild(createPlaceholderCard());
            } else {
                for (const download of actuallyActive) {
                    activeContainer.appendChild(createDownloadCard(download));
                }
                // Start polling for progress updates
                startProgressPolling();
            }
            
            // Populate queued
            queuedContainer.innerHTML = '';
            if (queuedDownloads.length === 0) {
                queuedContainer.appendChild(createPlaceholderCard());
            } else {
                for (const download of queuedDownloads) {
                    queuedContainer.appendChild(createDownloadCard(download));
                }
            }
            
            // Populate completed
            completedContainer.innerHTML = '';
            if (completedDownloads.length === 0) {
                completedContainer.appendChild(createPlaceholderCard());
            } else {
                for (const download of completedDownloads) {
                    completedContainer.appendChild(createDownloadCard(download));
                }
            }
            
            // Populate failed
            failedContainer.innerHTML = '';
            if (failedDownloads.length === 0) {
                failedContainer.appendChild(createPlaceholderCard());
            } else {
                for (const download of failedDownloads) {
                    failedContainer.appendChild(createDownloadCard(download));
                }
            }
            
        } catch (err) {
            activeContainer.innerHTML = '<div style="color: #f44336; padding: 20px;">Error loading downloads</div>';
        } finally {
            isLoadingDownloads = false;
        }
    }

    function getImageUrlFromJellyfinId(jellyfinId) {
        if (!jellyfinId || !window.ApiClient) return '';
        
        try {
            return window.ApiClient.getUrl(`Items/${jellyfinId}/Images/Primary`, {
                maxWidth: 300,
                quality: 90
            });
        } catch {
            return '';
        }
    }

    // ============================================
    // PROGRESS POLLING
    // ============================================

    function startProgressPolling() {
        stopProgressPolling();
        
        progressPollingInterval = setInterval(async () => {
            try {
                if (!window.ApiClient || !dropdownMenu || dropdownMenu.style.display !== 'block') {
                    stopProgressPolling();
                    return;
                }
                
                const response = await window.ApiClient.fetch({
                    type: 'GET',
                    url: window.ApiClient.getUrl('api/baklava/downloads'),
                    dataType: 'json'
                });
                
                if (response && response.active && response.active.length > 0) {
                    const activeDownloads = response.active;
                    
                    // Update dropdown cards
                    if (dropdownMenu && dropdownMenu.style.display === 'block') {
                        for (const download of activeDownloads) {
                            const progress = download.progress || download.Progress || 0;
                            const downloadId = download.id || download.Id;
                            
                            const card = dropdownMenu.querySelector(`[data-download-id="${downloadId}"]`);
                            if (card) {
                                const progressFill = card.querySelector('.download-progress-fill');
                                const progressText = card.querySelector('.download-progress-text');
                                if (progressFill) progressFill.style.width = `${progress}%`;
                                if (progressText) progressText.textContent = `${Math.round(progress)}%`;
                            }
                        }
                    }
                    
                    // Update modal if open
                    const modal = document.getElementById('downloadModal');
                    if (modal) {
                        const modalDownloadId = modal.getAttribute('data-download-id');
                        const download = activeDownloads.find(d => (d.id || d.Id) === modalDownloadId);
                        if (download) {
                            const progress = download.progress || download.Progress || 0;
                            const progressBar = modal.querySelector('.modal-progress-bar');
                            const progressFill = modal.querySelector('.modal-progress-fill');
                            const progressPercentage = modal.querySelector('.modal-progress-percentage');
                            
                            if (progressBar) progressBar.style.width = `${progress}%`;
                            if (progressFill) progressFill.style.width = `${progress}%`;
                            if (progressPercentage) progressPercentage.textContent = `${Math.round(progress)}%`;
                        }
                    }
                } else {
                    stopProgressPolling();
                    if (dropdownMenu && dropdownMenu.style.display === 'block') {
                        loadDropdownDownloads();
                    }
                }
            } catch (err) {}
        }, 2000); // Poll every 2 seconds
    }

    function stopProgressPolling() {
        if (progressPollingInterval) {
            clearInterval(progressPollingInterval);
            progressPollingInterval = null;
        }
    }

    function showDropdown() {
        createBackdrop();
        createDropdown();
        loadDropdownDownloads();
        backdrop.style.display = 'block';
        dropdownMenu.style.display = 'block';
        // Prevent background scrolling
        document.body.style.overflow = 'hidden';
    }

    function hideDropdown() {
        if (backdrop) backdrop.style.display = 'none';
        if (dropdownMenu) dropdownMenu.style.display = 'none';
        // Restore background scrolling
        document.body.style.overflow = '';
        // Stop polling when dropdown is hidden
        stopProgressPolling();
    }

    function toggleDropdown(btn) {
        if (dropdownMenu && dropdownMenu.style.display === 'block') {
            hideDropdown();
        } else {
            showDropdown();
        }
    }

    // ============================================
    // HEADER BUTTON
    // ============================================

    function addDownloadsButton() {
        if (document.querySelector('.headerDownloadsButton')) return;
        
        const headerRight = document.querySelector('.headerRight');
        if (!headerRight) {
            setTimeout(addDownloadsButton, 500);
            return;
        }
        
        const btn = document.createElement('button');
        btn.setAttribute('is', 'paper-icon-button-light');
        btn.setAttribute('data-role', 'downloads-button');
        btn.className = 'headerButton headerButtonRight headerDownloadsButton paper-icon-button-light';
        btn.title = 'Downloads';
        btn.style.position = 'relative'; // Needed for badge positioning
        btn.innerHTML = '<span class="material-icons get_app" aria-hidden="true"></span>';
        
        // Find the requests button and insert downloads button after it
        const requestsButton = headerRight.querySelector('.headerRequestsButton');
        if (requestsButton) {
            // Insert after requests button
            requestsButton.parentNode.insertBefore(btn, requestsButton.nextSibling);
        } else {
            // Fallback: insert before user button
            const userButton = headerRight.querySelector('.headerUserButton');
            if (userButton) {
                headerRight.insertBefore(btn, userButton);
            } else {
                headerRight.appendChild(btn);
            }
        }
        
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleDropdown(btn);
        });
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    function init() {
        // Wait for ApiClient to be ready before checking admin
        const waitForApiClient = () => {
            if (window.ApiClient) {
                checkAdmin();
            } else {
                setTimeout(waitForApiClient, 100);
            }
        };
        waitForApiClient();
        
        // Add header button with retry logic
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                addDownloadsButton();
                // Retry a few times in case header loads late
                setTimeout(addDownloadsButton, 500);
                setTimeout(addDownloadsButton, 1500);
                setTimeout(addDownloadsButton, 3000);
            });
        } else {
            addDownloadsButton();
            setTimeout(addDownloadsButton, 500);
            setTimeout(addDownloadsButton, 1500);
            setTimeout(addDownloadsButton, 3000);
        }
        
        // Watch for header being added dynamically
        const headerObserver = new MutationObserver(() => {
            if (!document.querySelector('.headerDownloadsButton')) {
                addDownloadsButton();
            }
        });
        
        headerObserver.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Listen for download events
        document.addEventListener('downloadStarted', (e) => {
            console.log('[Downloads] Download started:', e.detail);
            if (dropdownMenu && dropdownMenu.style.display === 'block') {
                loadDropdownDownloads();
            }
        });

        document.addEventListener('downloadProgress', (e) => {
            const download = e.detail;
            
            // Update dropdown cards if visible
            if (dropdownMenu && dropdownMenu.style.display === 'block') {
                const card = dropdownMenu.querySelector(`[data-download-id="${download.id}"]`);
                if (card) {
                    const progressFill = card.querySelector('.download-progress-fill');
                    const progressText = card.querySelector('.download-progress-text');
                    if (progressFill) {
                        progressFill.style.width = `${download.progress}%`;
                    }
                    if (progressText) {
                        progressText.textContent = `${Math.round(download.progress)}%`;
                    }
                }
            }

            // Update modal if open
            if (download._modalElement) {
                const modal = download._modalElement;
                const progressBar = modal.querySelector('.modal-progress-bar');
                const progressFill = modal.querySelector('.modal-progress-fill');
                const progressPercentage = modal.querySelector('.modal-progress-percentage');
                
                if (progressBar) {
                    progressBar.style.width = `${download.progress}%`;
                }
                if (progressFill) {
                    progressFill.style.width = `${download.progress}%`;
                }
                if (progressPercentage) {
                    progressPercentage.textContent = `${Math.round(download.progress)}%`;
                }
            }
        });

        document.addEventListener('downloadCompleted', (e) => {
            console.log('[Downloads] Download completed:', e.detail);
            if (dropdownMenu && dropdownMenu.style.display === 'block') {
                loadDropdownDownloads();
            }
            
            // Show notification
            if (window.Dashboard && window.Dashboard.alert) {
                window.Dashboard.alert(`Download completed: ${e.detail.title}`);
            }
        });

        document.addEventListener('downloadFailed', (e) => {
            console.log('[Downloads] Download failed:', e.detail);
            if (dropdownMenu && dropdownMenu.style.display === 'block') {
                loadDropdownDownloads();
            }
        });
    }

    // Start initialization
    init();
    
    // Expose global interface for external access
    window.DownloadsWindow = {
        show: showDropdown,
        hide: hideDropdown,
        reload: loadDropdownDownloads
    };
    
    // ============================================
    // PLAYBACK INTERCEPTOR FOR LOCAL FILES
    // ============================================
    
    // Intercept fetch requests to redirect stream URLs for downloaded content
    const originalFetch = window.fetch;
    window.fetch = function(...args) {
        const [url, options] = args;
        
        // Check if we have a pending download playback
        if (window._baklavaCurrentDownload) {
            const urlStr = url.toString();
            const jellyfinId = window._baklavaCurrentDownload.jellyfinId;
            
            // If this is a playback info request for our downloaded item
            if (urlStr.includes(jellyfinId) && urlStr.includes('/PlaybackInfo')) {
                console.log('[Downloads] Intercepted PlaybackInfo request:', urlStr);
                
                // Let it go through but we'll modify the response
                return originalFetch.apply(this, args).then(response => {
                    return response.clone().json().then(data => {
                        console.log('[Downloads] Original PlaybackInfo:', data);
                        
                        // Modify media sources to point to our download
                        if (data.MediaSources && data.MediaSources.length > 0) {
                            data.MediaSources = data.MediaSources.map(source => {
                                // Replace the source with direct play of our local file
                                return {
                                    ...source,
                                    SupportsTranscoding: false,
                                    SupportsDirectPlay: true,
                                    SupportsDirectStream: true,
                                    Path: window._baklavaCurrentDownload.streamUrl,
                                    DirectStreamUrl: window._baklavaCurrentDownload.streamUrl,
                                    TranscodingUrl: null,
                                    TranscodingSubProtocol: null
                                };
                            });
                            
                            console.log('[Downloads] Modified PlaybackInfo:', data);
                        }
                        
                        // Return modified response
                        return new Response(JSON.stringify(data), {
                            status: response.status,
                            statusText: response.statusText,
                            headers: response.headers
                        });
                    });
                });
            }
            
            // If this is a video stream request for our downloaded item, redirect it
            if (urlStr.includes(jellyfinId) && 
                (urlStr.includes('/stream') || urlStr.includes('/master.m3u8') || urlStr.includes('.mp4'))) {
                
                console.log('[Downloads] Intercepted stream request:', urlStr);
                console.log('[Downloads] Redirecting to local file:', window._baklavaCurrentDownload.streamUrl);
                
                // Redirect to our download stream endpoint
                return originalFetch(window._baklavaCurrentDownload.streamUrl, options);
            }
        }
        
        // Not a download playback, proceed normally
        return originalFetch.apply(this, args);
    };
    
    console.log('[Downloads] Playback interceptor installed');
})();

